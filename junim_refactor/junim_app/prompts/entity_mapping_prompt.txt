
## OBJETIVO
Converter estruturas de dados Delphi em entidades JPA otimizadas.

## MAPEAMENTO DE ENTIDADES
```java
@Entity
@Table(name = "table_name")
public class EntityName {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false, length = 100)
    private String name;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    // Relacionamentos
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL)
    private List<Child> children = new ArrayList<>();
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "category_id")
    private Category category;
}
```

## REPOSITORIES
```java
@Repository
public interface EntityRepository extends JpaRepository<EntityName, Long> {
    
    // Query methods por convenção
    List<EntityName> findByActiveTrue();
    Optional<EntityName> findByName(String name);
    
# Prompt aprimorado para mapeamento de entidades JPA

## OBJETIVO
Converter estruturas de dados Delphi em entidades JPA otimizadas, explicando o propósito de cada entidade, seu contexto de negócio e exemplos de uso.

## INSTRUÇÕES
- Para cada entidade identificada:
  - Explique em linguagem natural o que ela representa no sistema e seu papel nos fluxos de negócio.
  - Liste seus atributos, tipos e restrições, relacionando-os a requisitos do sistema.
  - Descreva exemplos práticos de uso dessa entidade (ex: "Um Cliente pode possuir vários Pedidos...").
  - Detalhe os relacionamentos (um-para-muitos, muitos-para-um, etc.) e explique o porquê de cada relação.
  - Se possível, forneça um diagrama textual simples das entidades e seus relacionamentos.

## MAPEAMENTO DE ENTIDADES
```java
@Entity
@Table(name = "table_name")
public class EntityName {
    // ... atributos, relacionamentos e comentários explicativos
}
```

## REPOSITORIES
```java
@Repository
public interface EntityRepository extends JpaRepository<EntityName, Long> {
    // Métodos de consulta por convenção e exemplos de queries relevantes para o negócio
}
```
    // Queries customizadas
    @Query("SELECT e FROM EntityName e WHERE e.status = :status")
    List<EntityName> findByStatus(@Param("status") String status);
    
    // Queries nativas se necessário
    @Query(value = "SELECT * FROM table_name WHERE complex_condition", nativeQuery = true)
    List<EntityName> findByComplexCondition();
}
```

## BOAS PRÁTICAS
- Usar tipos Java apropriados (LocalDateTime, BigDecimal)
- Lazy loading para relacionamentos
- CascadeType adequado
- Índices para performance
- Validações Bean Validation
