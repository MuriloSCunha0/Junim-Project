# Prompt para camada de serviços Spring

## OBJETIVO
Extrair e organizar lógica de negócio do Delphi em serviços Spring modulares.

## ESTRUTURA DE SERVICE
```java
@Service
@Transactional
public class BusinessService {
    
    private final EntityRepository repository;
    private final RelatedService relatedService;
    
    // Constructor injection
    public BusinessService(EntityRepository repository, RelatedService relatedService) {
        this.repository = repository;
        this.relatedService = relatedService;
    }
    
    public EntityDTO create(CreateEntityDTO dto) {
        // 1. Validações de negócio
        validateBusinessRules(dto);
        
        // 2. Conversão DTO → Entity
        Entity entity = mapToEntity(dto);
        
        // 3. Operações de negócio
        processBusinessLogic(entity);
        
        // 4. Persistência
        Entity saved = repository.save(entity);
        
        // 5. Pós-processamento
        handlePostCreation(saved);
        
        // 6. Conversão Entity → DTO
        return mapToDTO(saved);
    }
    
    @Transactional(readOnly = true)
    public EntityDTO findById(Long id) {
        Entity entity = repository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Entity not found: " + id));
        return mapToDTO(entity);
    }
    
    private void validateBusinessRules(CreateEntityDTO dto) {
        // Validações específicas do negócio
        if (someBusinessCondition(dto)) {
            throw new BusinessException("Business rule violation");
        }
    }
}
```

## RESPONSABILIDADES
- **Validações**: Regras de negócio específicas
- **Orquestração**: Coordenar operações complexas  
- **Transações**: Gerenciar consistência
- **Conversões**: DTO ↔ Entity
- **Exceções**: Tratar erros de negócio

## PADRÕES
- Constructor injection para dependências
- Métodos públicos para operações principais
- Métodos privados para lógica auxiliar
- @Transactional para operações de escrita
- @Transactional(readOnly = true) para consultas
