"""
Interface principal do JUNIM usando Streamlit
"""

import streamlit as st
import os
import tempfile
import logging
from datetime import datetime
from dotenv import load_dotenv

# Imports absolutos para evitar problemas de importa√ß√£o
import sys
from pathlib import Path

# Adiciona diret√≥rio pai ao path
current_dir = Path(__file__).parent
parent_dir = current_dir.parent
sys.path.append(str(parent_dir))

from core.pipeline import ModernizationPipeline
from utils.file_handler import FileHandler

# Import direto da interface de an√°lise
try:
    from ui.legacy_analysis_interface import render_legacy_analysis_interface
except ImportError:
    # Se falhar, criamos uma fun√ß√£o placeholder
    def render_legacy_analysis_interface():
        st.error("M√≥dulo de an√°lise n√£o dispon√≠vel. Verifique as depend√™ncias.")

# Configura√ß√£o do logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Carrega vari√°veis de ambiente
load_dotenv()

class JUNIMInterface:
    """Classe respons√°vel pela interface do usu√°rio do JUNIM"""
    
    def __init__(self):
        """Inicializa a interface"""
        self.file_handler = FileHandler()
        self.pipeline = None
        
    def run(self):
        """Executa a interface principal"""
        # Aplica CSS customizado
        add_custom_css()
        
        self._render_header()
        self._render_sidebar()
        self._render_main_content()
    
    def _render_header(self):
        """Renderiza o cabe√ßalho da aplica√ß√£o"""
        st.title("üöÄ JUNIM - Java Unified Interoperability Migration")
        st.markdown("""
        **Modernizador autom√°tico de sistemas Delphi para Java Spring Boot**
        
        Esta aplica√ß√£o utiliza IA generativa para converter projetos Delphi legados em aplica√ß√µes 
        Java Spring modernas, mantendo a l√≥gica de neg√≥cio e estrutura dos dados.
        """)
        
        st.divider()
    
    def _render_sidebar(self):
        """Renderiza a barra lateral com configura√ß√µes"""
        with st.sidebar:
            st.header("‚öôÔ∏è Configura√ß√µes")
            
            # Configura√ß√£o da API Groq
            st.subheader("API Groq")
            groq_api_key = st.text_input(
                "Chave da API Groq",
                type="password",
                value=os.getenv("GROQ_API_KEY", ""),
                help="Sua chave de API da Groq para acesso aos modelos LLM"
            )
            
            groq_model = st.selectbox(
                "Modelo Groq",
                ["llama3-70b-8192", "llama3-8b-8192", "mixtral-8x7b-32768"],
                index=0,
                help="Modelo da Groq a ser utilizado"
            )
            
            # Configura√ß√£o do Ollama (fallback)
            st.subheader("Ollama (Fallback)")
            ollama_url = st.text_input(
                "URL do Ollama",
                value=os.getenv("OLLAMA_URL", "http://localhost:11434"),
                help="URL da inst√¢ncia local do Ollama"
            )
            
            ollama_model = st.text_input(
                "Modelo Ollama",
                value=os.getenv("OLLAMA_DEFAULT_MODEL", "codellama:34b"),
                help="Modelo local do Ollama para fallback"
            )
            
            # Armazena configura√ß√µes na sess√£o
            st.session_state.config = {
                "groq_api_key": groq_api_key,
                "groq_model": groq_model,
                "ollama_url": ollama_url,
                "ollama_model": ollama_model
            }
            
            st.divider()
            
            # Informa√ß√µes do sistema
            st.subheader("‚ÑπÔ∏è Informa√ß√µes")
            st.info("""
            **Como usar:**
            1. Configure suas credenciais
            2. Fa√ßa upload do projeto Delphi (.zip)
            3. Clique em 'Modernizar'
            4. Baixe o projeto Java Spring
            """)
    
    def _render_main_content(self):
        """Renderiza o conte√∫do principal da interface"""
        
        # Navega√ß√£o por abas
        tab1, tab2, tab3 = st.tabs([
            "üîç An√°lise de Projeto Legado", 
            "üîÑ Moderniza√ß√£o Completa", 
            "üìä Dashboard"
        ])
        
        with tab1:
            # Nova funcionalidade de an√°lise detalhada
            render_legacy_analysis_interface()
        
        with tab2:
            # Funcionalidade original de moderniza√ß√£o
            self._render_modernization_interface()
        
        with tab3:
            # Dashboard de estat√≠sticas
            self._render_dashboard()
    
    def _render_modernization_interface(self):
        """Renderiza a interface de moderniza√ß√£o completa"""
        st.header("üîÑ Moderniza√ß√£o para Java Spring Boot")
        
        # Verifica se h√° projeto pr√©-carregado da an√°lise
        if self._has_analyzed_project():
            self._render_pre_loaded_project()
        else:
            self._render_upload_interface()
    
    def _has_analyzed_project(self):
        """Verifica se h√° um projeto analisado dispon√≠vel"""
        return (hasattr(st.session_state, 'analysis_results') and 
                st.session_state.analysis_results is not None and
                hasattr(st.session_state, 'generated_docs') and 
                st.session_state.generated_docs)
    
    def _render_pre_loaded_project(self):
        """Renderiza interface para projeto pr√©-carregado da an√°lise"""
        st.success("üéØ **Projeto pr√©-carregado da an√°lise!**")
        
        analysis = st.session_state.analysis_results
        docs = st.session_state.generated_docs
        
        # Informa√ß√µes do projeto analisado
        col1, col2, col3 = st.columns(3)
        
        with col1:
            project_name = analysis.get('metadata', {}).get('project_name', 'Projeto')
            st.metric("Projeto", project_name)
            st.info("An√°lise de projeto carregada e pronta para moderniza√ß√£o")
        
        with col2:
            units_count = len(analysis.get('units_analysis', {}))
            st.metric("Units Analisadas", units_count)
        
        with col3:
            docs_count = len(docs)
            st.metric("Documentos Gerados", docs_count)
        
        st.markdown("---")
        
        # Configura√ß√µes de moderniza√ß√£o
        self._render_modernization_settings()
        
        # Bot√£o de moderniza√ß√£o com documenta√ß√£o
        if st.button("üöÄ Modernizar com Documenta√ß√£o", type="primary", use_container_width=True):
            self._run_documentation_enhanced_modernization()
        
        st.markdown("---")
        
        # Op√ß√£o para carregar outro projeto
        with st.expander("üîÑ Carregar Projeto Diferente"):
            self._render_upload_interface(show_expander=False)
    
    def _render_upload_interface(self, show_expander=True):
        """Renderiza interface de upload de projeto"""
        col1, col2 = st.columns([2, 1])
        
        with col1:
            st.subheader("üìÅ Upload do Projeto Delphi")
            
            uploaded_file = st.file_uploader(
                "Selecione o arquivo .zip do projeto Delphi",
                type=["zip"],
                help="Fa√ßa upload de um arquivo .zip contendo todo o projeto Delphi (.pas, .dfm, etc.)"
            )
            
            if uploaded_file is not None:
                st.success(f"‚úÖ Arquivo carregado: {uploaded_file.name} ({uploaded_file.size} bytes)")
                
                # Configura√ß√µes de moderniza√ß√£o
                self._render_modernization_settings()
                
                # Bot√£o para iniciar moderniza√ß√£o
                if st.button("üîÑ Modernizar Projeto", type="primary", use_container_width=True):
                    self._run_modernization(uploaded_file)
        
        with col2:
            st.subheader("üìä Status")
            
            # Container para status em tempo real
            status_container = st.container()
            
            # Hist√≥rico de projetos (placeholder)
            if show_expander:
                with st.expander("üìà Estat√≠sticas"):
                    st.metric("Projetos Modernizados", "0", "0")
            else:
                st.metric("Projetos Modernizados", "0", "0")
    
    def _render_modernization_settings(self):
        """Renderiza configura√ß√µes da moderniza√ß√£o"""
        st.subheader("‚öôÔ∏è Configura√ß√µes da Moderniza√ß√£o")
        
        # Verifica√ß√£o de prompts
        with st.expander("ü§ñ Status dos Prompts Personalizados"):
            try:
                from prompts.specialized_prompts import PromptManager, prompt_manager
                st.success("‚úÖ **Seus prompts personalizados est√£o ativos!**")
                st.info("""
                **Prompts sendo utilizados:**
                - üß† An√°lise de funcionalidades
                - üîÑ Moderniza√ß√£o de c√≥digo
                - üìù Gera√ß√£o de documenta√ß√£o
                - üß™ Cria√ß√£o de testes
                """)
                
                # Mostra alguns detalhes dos prompts
                st.markdown("**Exemplo de prompt personalizado carregado:**")
                analysis_prompt = prompt_manager.get_analysis_prompt()
                st.code(analysis_prompt[:200] + "..." if len(analysis_prompt) > 200 else analysis_prompt, language="text")
                
            except ImportError as e:
                st.warning("‚ö†Ô∏è **Prompts padr√£o em uso**")
                st.error(f"Erro ao carregar prompts personalizados: {str(e)}")
                st.info("Para usar seus prompts personalizados, verifique se o arquivo `prompts/specialized_prompts.py` est√° configurado corretamente.")
        
        col1, col2 = st.columns(2)
        
        with col1:
            modernization_type = st.selectbox(
                "Tipo de Moderniza√ß√£o:",
                ["Convers√£o Completa", "Apenas Entidades", "Apenas APIs", "Apenas Servi√ßos"],
                help="Escolha o escopo da moderniza√ß√£o"
            )
            
            include_tests = st.checkbox(
                "Gerar Testes Unit√°rios",
                value=True,
                help="Inclui testes JUnit para o c√≥digo gerado"
            )
        
        with col2:
            use_specialized_prompts = st.checkbox(
                "Usar Prompts Especializados",
                value=True,
                help="Utiliza prompts otimizados para cada tipo de convers√£o"
            )
            
            generate_documentation = st.checkbox(
                "Gerar Documenta√ß√£o",
                value=True,
                help="Inclui documenta√ß√£o t√©cnica do c√≥digo Java"
            )
        
        # Armazena configura√ß√µes na sess√£o
        st.session_state.modernization_config = {
            'type': modernization_type,
            'include_tests': include_tests,
            'use_specialized_prompts': use_specialized_prompts,
            'generate_documentation': generate_documentation
        }
    
    def _run_documentation_enhanced_modernization(self):
        """Executa moderniza√ß√£o, gera e salva projeto Java completo (c√≥digo, docs, testes) em 'generated_project', com preview detalhado."""
        import shutil
        with st.spinner("üîÑ Gerando e salvando projeto Java modernizado..."):
            try:
                config = getattr(st.session_state, 'modernization_config', {})
                pipeline_config = st.session_state.config.copy()
                pipeline_config.update(config)
                
                # Debug da configura√ß√£o
                logger.info(f"Configura√ß√£o do pipeline: {pipeline_config}")
                logger.info(f"API Groq: {'Configurada' if pipeline_config.get('groq_api_key') else 'N√£o configurada'}")
                
                self.pipeline = ModernizationPipeline(pipeline_config)
                
                # FOR√áA o uso dos prompts especializados
                prompt_manager_loaded = False
                try:
                    from prompts.specialized_prompts import prompt_manager
                    self.pipeline.set_prompt_manager(prompt_manager)
                    prompt_manager_loaded = True
                    logger.info("‚úÖ Prompts especializados FOR√áADOS no pipeline")
                    st.info("ü§ñ **Usando seus prompts personalizados para moderniza√ß√£o!**")
                except ImportError as e:
                    logger.error(f"‚ùå Falha ao carregar prompts especializados: {str(e)}")
                    try:
                        from prompts.simple_loader import simple_prompt_loader as prompt_manager
                        self.pipeline.set_prompt_manager(prompt_manager)
                        st.warning("‚ö†Ô∏è **Usando prompts padr√£o como fallback**")
                    except ImportError:
                        st.error("‚ùå **Nenhum sistema de prompts dispon√≠vel!**")
                        return
                
                # Valida√ß√£o adicional
                if not hasattr(self.pipeline, 'prompt_manager') or self.pipeline.prompt_manager is None:
                    st.error("‚ùå **Erro cr√≠tico: Pipeline sem prompts configurados!**")
                    return
                self.pipeline.set_analysis_data(
                    st.session_state.analysis_results,
                    st.session_state.generated_docs
                )
                progress_bar = st.progress(0)
                status_text = st.empty()
                def update_progress(step, total_steps, message):
                    progress = step / total_steps
                    progress_bar.progress(progress)
                    status_text.text(f"Passo {step}/{total_steps}: {message}")
                # Executa pipeline real e salva projeto em 'generated_project'
                # Executa moderniza√ß√£o usando dados de an√°lise pr√©via
                status_text.text("üìã Preparando moderniza√ß√£o...")
                progress_bar.progress(10)
                java_project_path = self.pipeline.run(
                    progress_callback=lambda s, t, m: update_progress(s, t, m)
                )
                # Copia tudo para 'generated_project'
                target_dir = os.path.abspath(os.path.join(os.getcwd(), 'generated_project'))
                if os.path.exists(target_dir):
                    shutil.rmtree(target_dir)
                shutil.copytree(java_project_path, target_dir)
                # Copia documenta√ß√£o gerada
                docs_dir = os.path.abspath(os.path.join(os.getcwd(), 'generated_docs'))
                if os.path.exists(docs_dir):
                    shutil.copytree(docs_dir, os.path.join(target_dir, 'documentacao'))
                status_text.text("‚úÖ Projeto Java modernizado salvo em 'generated_project'!")
                progress_bar.progress(100)
                st.success(f"üéâ Projeto Java modernizado salvo em: {target_dir}")
                # Preview detalhado
                enhanced_prompt = prompt_manager.get_documentation_enhanced_prompt(
                    analysis_results=st.session_state.analysis_results,
                    generated_docs=st.session_state.generated_docs
                )
                self._show_modernization_preview(enhanced_prompt)
                # Salva no hist√≥rico
                if 'modernization_history' not in st.session_state:
                    st.session_state.modernization_history = []
                st.session_state.modernization_history.append({
                    'timestamp': datetime.now().isoformat(),
                    'type': 'documentation_enhanced',
                    'config': config,
                    'project_name': st.session_state.analysis_results.get('metadata', {}).get('project_name', 'Unknown')
                })
            except Exception as e:
                st.error(f"‚ùå Erro durante moderniza√ß√£o: {str(e)}")
                logger.error(f"Erro na moderniza√ß√£o com documenta√ß√£o: {str(e)}")
    
    def _show_modernization_preview(self, enhanced_prompt: str):
        """Mostra preview do que seria gerado na moderniza√ß√£o, incluindo testes automatizados."""
        st.subheader("üëÄ Preview da Moderniza√ß√£o")

        # Tabs para diferentes aspectos
        preview_tab1, preview_tab2, preview_tab3, preview_tab4 = st.tabs([
            "üìù Prompt Gerado",
            "üèóÔ∏è Estrutura Planejada",
            "üß™ Testes Automatizados",
            "üìä M√©tricas"
        ])

        with preview_tab1:
            st.markdown("**Prompt enriquecido com documenta√ß√£o:**")
            st.text_area(
                "Prompt que seria usado para gerar o c√≥digo Java:",
                value=enhanced_prompt[:2000] + "..." if len(enhanced_prompt) > 2000 else enhanced_prompt,
                height=300,
                disabled=True
            )

        with preview_tab2:
            st.markdown("**Estrutura Java Spring que seria gerada:**")
            st.code("""
src/main/java/com/projeto/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ DatabaseConfig.java
‚îÇ   ‚îî‚îÄ‚îÄ WebConfig.java
‚îú‚îÄ‚îÄ controller/
‚îÇ   ‚îú‚îÄ‚îÄ CustomerController.java
‚îÇ   ‚îî‚îÄ‚îÄ ProductController.java
‚îú‚îÄ‚îÄ service/
‚îÇ   ‚îú‚îÄ‚îÄ CustomerService.java
‚îÇ   ‚îî‚îÄ‚îÄ ProductService.java
‚îú‚îÄ‚îÄ repository/
‚îÇ   ‚îú‚îÄ‚îÄ CustomerRepository.java
‚îÇ   ‚îî‚îÄ‚îÄ ProductRepository.java
‚îú‚îÄ‚îÄ entity/
‚îÇ   ‚îú‚îÄ‚îÄ Customer.java
‚îÇ   ‚îî‚îÄ‚îÄ Product.java
‚îú‚îÄ‚îÄ dto/
‚îÇ   ‚îú‚îÄ‚îÄ CustomerDTO.java
‚îÇ   ‚îî‚îÄ‚îÄ ProductDTO.java
‚îî‚îÄ‚îÄ exception/
    ‚îú‚îÄ‚îÄ GlobalExceptionHandler.java
    ‚îî‚îÄ‚îÄ BusinessException.java
            """, language="text")

        with preview_tab3:
            st.markdown("**Exemplo de Testes Automatizados Gerados:**")
            # Exemplo did√°tico baseado no novo prompt de testes
            st.code(
                """
@WebMvcTest(CustomerController.class)
class CustomerControllerTest {
    // Teste: Usu√°rio cadastra cliente com dados v√°lidos
    @Test
    void deveCadastrarClienteComSucesso() throws Exception {
        // ... implementa√ß√£o do teste
    }

    // Teste: Busca cliente inexistente retorna 404
    @Test
    void deveRetornar404ParaClienteInexistente() throws Exception {
        // ... implementa√ß√£o do teste
    }
}

@ExtendWith(MockitoExtension.class)
class CustomerServiceTest {
    // Teste: Regra de neg√≥cio - nome obrigat√≥rio
    @Test
    void deveLancarExcecaoSeNomeVazio() {
        // ... implementa√ß√£o do teste
    }
}

@DataJpaTest
class CustomerRepositoryTest {
    // Teste: Consulta clientes ativos
    @Test
    void deveBuscarClientesAtivos() {
        // ... implementa√ß√£o do teste
    }
}
                """,
                language="java"
            )

        with preview_tab4:
            analysis = st.session_state.analysis_results
            col1, col2, col3 = st.columns(3)
            with col1:
                units_count = len(analysis.get('units_analysis', {}))
                estimated_classes = units_count * 2  # Estimativa
                st.metric("Classes Java Estimadas", estimated_classes)
            with col2:
                total_lines = sum(unit.get('lines_count', 0) for unit in analysis.get('units_analysis', {}).values())
                estimated_java_lines = int(total_lines * 1.3)  # Estimativa
                st.metric("Linhas Java Estimadas", f"{estimated_java_lines:,}")
            with col3:
                config = getattr(st.session_state, 'modernization_config', {})
                features = sum([
                    config.get('include_tests', False),
                    config.get('generate_documentation', False),
                    config.get('use_specialized_prompts', False)
                ])
                st.metric("Recursos Habilitados", features)
    
    def _render_dashboard(self):
        """Renderiza dashboard de estat√≠sticas e informa√ß√µes"""
        st.header("üìä Dashboard do JUNIM")
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                label="üîç An√°lises Realizadas",
                value=len(getattr(st.session_state, 'analysis_history', [])),
                delta=None
            )
        
        with col2:
            st.metric(
                label="üîÑ Moderniza√ß√µes",
                value=len(getattr(st.session_state, 'modernization_history', [])),
                delta=None
            )
        
        with col3:
            st.metric(
                label="üìÑ Documentos Gerados",
                value=len(getattr(st.session_state, 'generated_docs', {})),
                delta=None
            )
        
        with col4:
            st.metric(
                label="‚öôÔ∏è Configura√ß√µes",
                value="OK" if hasattr(st.session_state, 'config') else "Pendente",
                delta=None
            )
        
        # Informa√ß√µes sobre o sistema
        st.subheader("‚ÑπÔ∏è Sobre o JUNIM")
        st.markdown("""
        ### Java Unified Interoperability Migration
        
        **JUNIM** √© uma ferramenta avan√ßada para moderniza√ß√£o de sistemas legados Delphi, 
        oferecendo an√°lise detalhada e migra√ß√£o autom√°tica para Java Spring Boot.
        
        #### üéØ Principais Funcionalidades:
        
        1. **üìã An√°lise Detalhada**: Extra√ß√£o de requisitos, funcionalidades e fluxos
        2. **üìù Documenta√ß√£o Autom√°tica**: Gera√ß√£o de documenta√ß√£o t√©cnica completa
        3. **üîó Mapeamento de Correla√ß√µes**: Delphi ‚Üí Java Spring equivalentes
        4. **üîÑ Moderniza√ß√£o Completa**: Convers√£o autom√°tica do c√≥digo
        5. **üìä M√©tricas de Qualidade**: An√°lise de complexidade e manutenibilidade
        
        #### üõ†Ô∏è Tecnologias Utilizadas:
        - **Python** com Streamlit para interface
        - **Groq API** para processamento IA de alto desempenho
        - **Ollama** para modelos locais como fallback
        - **Regex avan√ßado** para parsing de c√≥digo Delphi
        - **Templates Spring Boot** para gera√ß√£o de c√≥digo
        
        #### üìà Benef√≠cios:
        - ‚ö° **Rapidez**: An√°lise em minutos vs. semanas manuais
        - üéØ **Precis√£o**: Preserva√ß√£o da l√≥gica de neg√≥cio
        - üìö **Documenta√ß√£o**: Cria√ß√£o autom√°tica de documenta√ß√£o t√©cnica
        - üîÑ **Iterativo**: An√°lise antes da moderniza√ß√£o
        - üõ°Ô∏è **Confi√°vel**: M√∫ltiplas valida√ß√µes e verifica√ß√µes
        """)
        
        # Configura√ß√µes atuais
        if hasattr(st.session_state, 'config'):
            with st.expander("‚öôÔ∏è Configura√ß√µes Atuais"):
                config = st.session_state.config
                st.json({
                    "groq_model": config.get("groq_model", "N/A"),
                    "ollama_model": config.get("ollama_model", "N/A"),
                    "ollama_url": config.get("ollama_url", "N/A"),
                    "groq_configured": bool(config.get("groq_api_key", "")),
                })
        
        # Links √∫teis
        st.subheader("üîó Links √öteis")
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.markdown("""
            **üìö Documenta√ß√£o**
            - [Spring Boot Guide](https://spring.io/guides)
            - [Java Migration Best Practices](https://docs.oracle.com/javase/8/docs/)
            """)
        
        with col2:
            st.markdown("""
            **üõ†Ô∏è Ferramentas**
            - [Groq Console](https://console.groq.com/)
            - [Ollama Documentation](https://ollama.ai/docs)
            """)
        
        with col3:
            st.markdown("""
            **üéì Recursos**
            - [Delphi to Java Migration](https://example.com)
            - [Legacy System Modernization](https://example.com)
            """)
    
    
    def _run_modernization(self, uploaded_file):
        """Executa o pipeline de moderniza√ß√£o"""
        try:
            # Valida√ß√£o do arquivo
            if uploaded_file is None:
                st.error("‚ùå Arquivo n√£o encontrado. Por favor, fa√ßa o upload novamente.")
                return
            
            # Verifica se o arquivo tem os m√©todos necess√°rios
            if not hasattr(uploaded_file, 'getvalue') and not hasattr(uploaded_file, 'getbuffer'):
                st.error("‚ùå Arquivo inv√°lido. Por favor, fa√ßa o upload de um arquivo ZIP v√°lido.")
                return
            
            # Carrega configura√ß√µes da moderniza√ß√£o
            config = getattr(st.session_state, 'modernization_config', {})
            
            # Inicializa o pipeline com as configura√ß√µes
            pipeline_config = st.session_state.config.copy()
            pipeline_config.update(config)
            self.pipeline = ModernizationPipeline(pipeline_config)
            
            # Container para progresso
            progress_container = st.container()
            
            with progress_container:
                st.header("üîÑ Moderniza√ß√£o em Andamento")
                
                # Barra de progresso
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                # Callback para atualizar progresso
                def update_progress(step, total_steps, message):
                    progress = step / total_steps
                    progress_bar.progress(progress)
                    status_text.text(f"Passo {step}/{total_steps}: {message}")
                
                # Cria arquivo tempor√°rio para o upload
                with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as tmp_file:
                    try:
                        # Tenta usar getvalue() primeiro, depois getbuffer()
                        if hasattr(uploaded_file, 'getvalue'):
                            file_content = uploaded_file.getvalue()
                        elif hasattr(uploaded_file, 'getbuffer'):
                            uploaded_file.seek(0)  # Garante que est√° no in√≠cio
                            file_content = uploaded_file.getbuffer()
                        else:
                            raise Exception("M√©todo de leitura do arquivo n√£o suportado")
                        
                        if len(file_content) == 0:
                            st.error("‚ùå Arquivo est√° vazio. Por favor, selecione um arquivo v√°lido.")
                            return
                        
                        tmp_file.write(file_content)
                        temp_path = tmp_file.name
                        
                        # Valida se o arquivo foi criado corretamente
                        if not os.path.exists(temp_path) or os.path.getsize(temp_path) == 0:
                            st.error("‚ùå Erro ao criar arquivo tempor√°rio.")
                            return
                        
                    except Exception as file_error:
                        st.error(f"‚ùå Erro ao processar arquivo: {str(file_error)}")
                        logger.error(f"Erro ao processar arquivo no pipeline: {str(file_error)}")
                        return
                
                try:
                    # FOR√áA o uso de prompts especializados
                    if config.get('use_specialized_prompts', True):
                        try:
                            from prompts.specialized_prompts import prompt_manager
                            update_progress(1, 8, "‚úÖ Carregando SEUS prompts especializados...")
                            self.pipeline.set_prompt_manager(prompt_manager)
                            logger.info("‚úÖ Prompts especializados configurados com sucesso")
                        except ImportError as e:
                            logger.warning(f"‚ö†Ô∏è Falha ao importar prompts especializados: {str(e)}")
                            try:
                                from prompts.simple_loader import simple_prompt_loader
                                update_progress(1, 8, "‚ö†Ô∏è Carregando prompts padr√£o...")
                                self.pipeline.set_prompt_manager(simple_prompt_loader)
                            except ImportError:
                                st.error("‚ùå Nenhum sistema de prompts dispon√≠vel!")
                                return
                    else:
                        st.info("‚ÑπÔ∏è Prompts especializados desabilitados pelo usu√°rio")
                    
                    # Valida√ß√£o cr√≠tica
                    if not hasattr(self.pipeline, 'prompt_manager') or self.pipeline.prompt_manager is None:
                        st.error("‚ùå **ERRO: Pipeline sem prompts! Interrompendo processo.**")
                        return
                    
                    # Se h√° an√°lise pr√©via, carrega os dados e n√£o passa caminho do projeto
                    if self._has_analyzed_project():
                        update_progress(2, 8, "Carregando dados de an√°lise pr√©via...")
                        self.pipeline.set_analysis_data(
                            st.session_state.analysis_results,
                            st.session_state.generated_docs
                        )
                        
                        # Executa o pipeline sem passar o caminho do projeto
                        logger.info("Executando pipeline com dados de an√°lise pr√©via")
                        result_path = self.pipeline.run(
                            delphi_project_path=None,  # N√£o passa caminho para usar an√°lise pr√©via
                            progress_callback=lambda s, t, m: update_progress(s + 3, 8, m)
                        )
                    else:
                        # Valida o arquivo antes de passar para o pipeline
                        if not temp_path or not os.path.exists(temp_path):
                            st.error("‚ùå Arquivo tempor√°rio n√£o encontrado.")
                            return
                        
                        logger.info(f"Executando pipeline com arquivo: {temp_path}")
                        
                        # Executa o pipeline com o arquivo
                        result_path = self.pipeline.run(
                            delphi_project_path=temp_path,
                            progress_callback=lambda s, t, m: update_progress(s + 3, 8, m)
                        )
                    
                    # Sucesso - oferece download
                    progress_bar.progress(1.0)
                    status_text.text("‚úÖ Moderniza√ß√£o conclu√≠da com sucesso!")
                    
                    st.success("üéâ Projeto modernizado com sucesso!")
                    
                    # Mostra estat√≠sticas da moderniza√ß√£o
                    self._show_modernization_stats()
                    
                    # Bot√£o de download
                    with open(result_path, 'rb') as file:
                        st.download_button(
                            label="üì• Baixar Projeto Java Spring",
                            data=file.read(),
                            file_name="modernized_project.zip",
                            mime="application/zip",
                            type="primary",
                            use_container_width=True
                        )
                    
                    # Limpa arquivo tempor√°rio
                    os.unlink(temp_path)
                    os.unlink(result_path)
                    
                except Exception as e:
                    st.error(f"‚ùå Erro durante a moderniza√ß√£o: {str(e)}")
                    status_text.text(f"‚ùå Erro: {str(e)}")
                    
                    # Limpa arquivo tempor√°rio
                    if os.path.exists(temp_path):
                        os.unlink(temp_path)
                    
        except Exception as e:
            st.error(f"‚ùå Erro ao inicializar pipeline: {str(e)}")
    
    def _render_footer(self):
        """Renderiza o rodap√© da aplica√ß√£o"""
        st.divider()
        st.markdown("""
        ---
        **JUNIM v1.0** - Desenvolvido como parte do TCC de Sistemas de Informa√ß√£o  
        *Powered by IA Generativa (Groq/Ollama) + RAG*
        """)

# Adiciona CSS customizado
def add_custom_css():
    """Adiciona estilos CSS customizados"""
    st.markdown("""
    <style>
    .main-header {
        background: linear-gradient(90deg, #1f4e79, #2d5aa0);
        padding: 1rem;
        border-radius: 10px;
        color: white;
        margin-bottom: 1rem;
    }
    
    .status-box {
        background: #f0f2f6;
        border-left: 5px solid #1f4e79;
        padding: 1rem;
        border-radius: 5px;
        margin: 1rem 0;
    }
    
    .success-box {
        background: #d4edda;
        border-left: 5px solid #28a745;
        padding: 1rem;
        border-radius: 5px;
        margin: 1rem 0;
    }
    
    .error-box {
        background: #f8d7da;
        border-left: 5px solid #dc3545;
        padding: 1rem;
        border-radius: 5px;
        margin: 1rem 0;
    }
    </style>
    """, unsafe_allow_html=True)

